
 - 일반적인 랜더링 파이프라인

   모니터는 픽셀의 집합이며 우리는 전혀 보이진 않지만 개념상 월드라는 것(x, y, z로 이뤄진 세상)을 만들어 모니터에 출력하고자 한다.
   어떤 세상에 존재(아직 Mesh라는 것이 없는 것)가 있다는 것을 표현하려고 한다면, 우리 엔진에서는 이를 GameEngineTransform이 도와준다.
   어떤 점이 있다면, 이 점은 점이 바라보는 방향, 점의 위치, 점의 회전 값에 대한 집합(Worldmatrix)을 가지고 있다.
   이 정보만으로는 화면에 출력될 수 없다.
   그렇기 때문에 이 점(vertex)들을 모아(연결) 삼각형(mesh)로 만든다.
   이 삼각형의 각 점들이 우리가 만든 Worldmatrix(행렬)에 영향을 받게 된다.

   삼각형이 화면 가운데에 존재한다고 가정해보자.
   이것이 Worldmatrix에 영향을 받을 경우 크자이공부가 적용된다.
   또한 화면에 출력하기 위해 카메라를 하나 만든다.
   카메라는 화각, near, far 등의 정보를 갖고 뷰 -> 프로젝션 -> 뷰포트 작업을 한 뒤 모니터에 삼각형을 띄운다.
   이때 카메라가 정보를 통해 물체를 화면에 띄우기 전, 물체를 담는 공간을 피라미드(프로스텀)이라고 한다.
   프로스텀 안에 mesh를 가진 존재가 들어오면 뷰포트가 곱해지면서 화면에 위치하게 되는 것이다.
   프로스텀에 포함되지 않는 것들은 화면에 표시되지 않는다.
 
 - Direct의 랜더링 파이프라인

   GameEngineBase의 랜파.jpg를 보면서 확인
   맨 처음 단계 Input Assembler는 점을 준비하라는 뜻이다.

   최초에 화면에 점이 위치한다면, 이건 점이 Worldmatrix를 통해 위치만 결정된 것이다.
   아직 색에 대한 정보는 담고 있지 않다.
   사실 점은 위치 뿐만 아니라 여러 정보를 담을 수 있는데, 두 번째로 중요한 것이 바로 색깔 정보이다.
   화면에 특정 색을 갖는 존재가 표현된다면, 색을 가지고 있다. 이 색을 표현하기 위한 정보를 점이 가지고 있으며 안티얼라이어싱을 통해 색을 결정하는 것이다.
   이 점들을 만들어서 DirectX에게 전달해야 한다.

   지금까지는 점의 위치만 보낸 것이다. 물론 위치 정보는 필수이기 때문에 보내야 한다.
   
   이를 위해 GameEngineVertex를 추가하여 내부에 float4 Vertex, float4 Color를 추가한다.

 - 인스턴스 버퍼
   Input Assembler에 화살표 왼쪽으로 연결된 부분에서 인스턴스 버퍼란, DirectX에 넘길 정점을 그리기 위한 버퍼

 - 현재까지는 Vertex에서 점의 위치만 정보로 보냈다.
   점에는 위치 뿐만 아니라 색깔 등 여러가지 정보를 담을 수 있다.
   GameEngineVertex를 추가하여 위치와 정보에 대해 선언

 - 인덱스 버퍼
   점이 몇 개인지, 어떤 순서로 그릴지에 대한 정보를 넘겨주는 버퍼
 
 ------------------------------------------------------------------------------------------------------------------------------------------------------
   랜더링 파이프라인 EX (0411)

- 아직 Input Assembler1 단계가 끝나지 않았다.
  랜더링 파이프라인의 단계를 가지고 있는 클래스를 하나 선언 - GameEngineRenderingPipeLine

- 매쉬와 머터리얼은 3D 프로그래밍 라이브러리의 단계를 나눠서 하나의 개념으로 표현하기 위해 쓰는 말이다.
  실제로 랜파.jgp는 DirectX의 랜더링 파이프라인인데, Mesh와 Merterial이라는 개념이 존재하지 않는다.
  그래도 통용되서 쓰이는 개념에 따라 다렉 랜파의 단계를 묶어보면
  Mesh = Input Assembler1 / VertexShader / Input Assembler2 / 래스터라이저
  Merterial = PixelShader / Outmerger

- InputAssembler
  DeviceContext->IASetVertexBuffer()

  인자로 ID3D11Buffer를 넘겨준다.
  화면에 나오는, 색이 입혀지지 않은 도형을 생각해보자. 이 매쉬를 그리기 위해 점들을 생성하는 단계

- VertexShader
  DeviceContext->VSSetShader()

  정점 네 개로 이뤄진 rect를 그린다면, VertexShader는 네 번 동작한다.
  CoreResoucresInit() 함수를 확인해보면 rect는 네 개의 Vertex가 필요하다. 이 정보는 로컬 스페이스에 담겨있는 것이다.
  이 로컬 상의 점들에 대해 행렬을 통해 변환을 실시한다. 여기서 Projection까지 실시.

- Input Assembler2
  DeviceContext->IASetIndexBuffer()

  생성된 점들에 대해 어떤 순서로 이을지 (그릴지) 정한다.

-------------------------------------------------------------
- 여기서 부터는 화면에 출력되는 과정에 꼭 필요한 단계는 아니다.

- Hullshaer와 테셀레이션
  Vertex 쪼개기다.
  일반적으로 rect를 만들었다고 하면, 그게 변할리는 없다.
  근데 배틀그라운드에서 시야를 중간 정도로 한 뒤 굉장히 먼 곳을 바라보면 액터가 찌그려져서 보일 때가 있을 것이다.
  헐셰이더가 정점을 쪼개고, 테셀레이션이 그걸 토대로 매시를 비트는 것이다.
  어떤 액터를 표현하는데 최대 1000만개의 정점이 필요하다고 가정하면
  lod(Level of detail)에 따라 멀리서 볼때는 100만개로만 표현 이런 식으로 한다.
  매쉬를 단계에 따라 n개 만들 수 있다.

  1m = 1000만개
  10m = 100만개
  100m = 10만개
  1000m = 만개 

  이런 식으로 lod에 따라 달라지게 한다.

- 도메인 셰이더와 지오매트리 셰이더
  도메인 셰이더는 입자 처리, 지오메트리 셰이더는 버텍스 생성이다.

  이 단계에서는 없던 버텍스를 생성한다. 주로 파티클(입자) 생성에 활용하는 단계.
  파티클은 어마어마하게 많은 양의 동일한 버텍스를 화면에 뿌리는 것이다.

  지오메트리 단계에는 지오메트리 셰이더와 인스턴싱이 있는데, 인스턴싱이 조금 더 빠르나 사실 별로 의미없다(우리는 안배울 예정이라).
  도메인 셰이더에서 어떤 버텍스가 들어오면 특정한 정보를 부여하고, 지오메트리 셰이더가 이 정보가 담긴 버텍스를 더 만들어내고, 어떻게 그릴지 정한다.
  >> 이 과정(CoreResourcesInit())을 GPU한테 시킬 수 있음

---------------------------------------------------------------

- 래스터라이저
  DeviceContext->RSSetState()

  프로젝션까지 적용된 버텍스에 대해 w 나누기를 해주고
  뷰 포트 행렬을 곱해준다.
  화면 컬링(액터가 화면내에 출력되지 않고 짤려야 할 경우 컷하는 과정)도 해준다.
  또한 화면에 어떤 픽셀에 물체의 정보가 담겨야 하는지, 픽셀 건지기(선생님의 표현)도 해준다. 물체가 존재해야 하는 픽셀을 체크하는것

- 픽셀셰이더
  DeviceContext->PSSetShader

  건지기로 어떤 픽셀에 매쉬의 정보가 출력되야 하는지 알아냈다면, 이제 색깔 입히기를 해야한다.
  버텍스에 저장된 Color를 기반으로 색을 찍게 된다.

- 아웃풋머저
  DeviceContext->OMSetRenderTarget()
  어떤 랜더 타겟에 그릴 것인지 결정하는 단계

  픽셀 셰이더까지 실시하여 형태와 색이 정해졌다고 하자.
  우리는 이미지 로드를 실시할 때마다 HDC가 생성된다는 것을 알고 있다.
  아마 게임을 만들려고 한다면 수천개의 이미지를 로드한 상태, 이러면 HDC가 숫자만큼 수천개 존재하게 된다.
  픽셀 셰이더에 담긴 그려야하는 정보를 이 수천개의 이미지에서 어디에 그릴 지 정하는 것이다.
  우리는 BackBuffer용 랜더타겟을 만들어놨음
  그러면 TextureLoad 하여 특정하게 그려진 HDC가 BackBuffer에 복사되고 윈도우창에 출력됨
