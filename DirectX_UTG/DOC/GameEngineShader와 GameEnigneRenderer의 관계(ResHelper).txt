
 GameEngineRenderer와 GameEngineShader는 GameEngineShaderResHelper를 객체로 가지고 있다.
 Shader의 GameEngineShaderResHelper는 상수 버퍼, 텍스쳐와 같은 리소스 정보(상수 버퍼가 몇개, 크기가 어떻고, 슬롯이 뭐고 이런 것)를 저장하고 있다.
 
 기존의 WinAPI에서는 GaemeEngineRender가 랜더링할 때 필요한 이미지, 알파값, 투명값 등을 멤버 변수로 가지고 있는 상태로
 알파블릿, 비트블릿, 트랜스블릿, 피엘지블릿 등을 활용해서 랜더링을 실시했다.
 이런 것은 함수가 지원하면 사용할 수 있고, 함수가 없으면 사용할 수 없었다(예를 들어서 Y축 회전하여 뒷면을 보고싶다고 해도, 함수가 지원 안하면 그 기능 못쓰는 것).

 이제 다이렉트로 넘어오면서 개념이 조금 바꼈다.
 제약이 없어진 것이다.
 랜더링을 위한 함수가 딱 하나 존재하고(랜더링 파이프라인), 그 과정을 여러 단계로 나눠서 세분화 했다.
 이 안에서 투명 처리, 회전, 투명값(제외값) 설정을 할 수 있는 것이다.
 또한, 예전에는 랜더러 하나에 이미지 하나만을 사용했지만, 다이렉트에서는 랜더러 하나에 여러 개의 이미지를 가지고 동시에 랜더링할 수 있다.
 단순하게 생각했을 때, 값을 하나 씩만 가지고 하나 씩만 출력하면 WinAPI와 다를게 없지만, 여러 개씩 가지기 때문에 복잡해지는 것
 지금은 이미지를 하나만 랜더링하는 조건이 아니라, 이미지를 여러 개 랜더링할 수 있는 조건을 만들기 위한 베이스를 구성하는 단계이다.

 이걸 위해서 버텍스 쉐이더나 픽셀 쉐이더는 회전하려면 몇도? 투명해지려는 알파값은 몇? 이런 것을 모르기 때문에, 값을 넣어줘야 하는데,
 이 값을 누가 들고 있고 어떻게 변경하는지를 결정해야 하는 것이다.
 WinAPI에서는 랜더러가 멤버 변수로 들고 있었는데, 우리의 엔진은 어떻게 할것이냐? (우선 위치, 크기, 이동과 같은 행렬 값은 Transform이 가지고 있다.)

 ShaderResourceCheck()을 통해 어떤 쉐이더가 몇 개의 텍스쳐와 몇 개의 상수 버퍼 정보를 가지고 있는지, 조건을 체크한다.
 이 정보를 저장하는 과정에서 ShaderResourceCheck()는 GameEngine"~"Setter를 활용하는데,
 이것은 세터가 특정 상수 버퍼 형태를 취하겠다고 지정하는 것 뿐으로 이후 GameEngineShaderResHelper 객체에 정보가 저장된다(몇개, 크기 어떻게, 몇번 슬롯)
 상수 버퍼가 존재한다는 것을 기록하기 위한 세터를 쉐이더가 가지고 있는 것이다.

 여기서 쉐이더와 랜더러는 별개의 클래스이기 때문에,
 랜더러가 세팅되는 시점(GameEngineRenderer::SetPipeLine)에 어떤 쉐이더를 쓰겠다고 지정해야 한다.
 이때, Copy를 통해 SetPipeLine으로 지정한 그 파이프라인 내의 쉐이더에 저장된 상수 버퍼를 자신의 GameEngineShaderResHelper 객체에 복붙하는 것. 이게 Copy이다.

 이 시점에서 만약 쉐이더 내의 세터(저장된 값) 정보에 색깔(빨파초흰검)이나 역할(배경인지, 캐릭터인지, 오브젝트인지)이 정해져 있다면
 랜더러의 색을 바꾸거나 역할을 아무리 바꾼다고 해도 엔진 구조상 Copy했기 때문에 안되는 것.
 이걸 막기 위해 세터 저장 단계는 상수 버퍼 세팅 값만 저장하는 것이다.
 이후에 뭔가를 이용해서 색깔이나 역할을 수정할 수 있도록 하는 것이 우리 엔진의 핵심 역할이다.

 결론적으로, 기성 엔진은 랜더러마다 파이프라인을 만드는데, 우리는 하나의 랜더링 파이프라인에서 쉐이더를 여러개 만들고,
 동일한 파이프라인을 쓰면서 원하는 쉐이더를 복붙하는 방식으로 구성한 것.
 만약 이게 맘에 안들었다면 랜더러 선언할 때마다 파이프라인 만들어서 쓰던가 입니다.