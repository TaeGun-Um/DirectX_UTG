#include <Windows.h>
#include <GameEngineBase\GameEngineFile.h>
#include <GameEngineBase\GameEngineDirectory.h>
#include <GameEngineCore\GameEngineCore.h>
#include <GameEngineContents\ContentsCore.h>

#pragma comment(lib, "GameEngineCore.lib")
#pragma comment(lib, "GameEngineContents.lib")

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
	_In_opt_ HINSTANCE hPrevInstance,
	_In_ LPWSTR    lpCmdLine,
	_In_ int       nCmdShow)
{
	GameEngineCore::Start(hInstance, ContentsCore::GameStart, ContentsCore::GameEnd);
}

// 모든 좌표계는 원점(0, 0)이 어딘지 파악하는게 중요하다.
// 원점으로부터 3개의 축벡터가 생성되며 어디로 가는 것이 양수인지가 중요하다.
// 
// 보통 데카르트 좌표계에서 z축은 안쪽으로 들어갈 수록 값이 증가한다. (왼손 좌표계를 기준으로 생각하면 됨)
// 세 축은 서로간에 수직이다.
// 
// 왼손좌표계 기준으로 봤을때, 2차원 평면에서는 z축을 기준으로 회전하면 x, y의 값이 변형된다. (z축 회전)
// 왼손좌표계의 z축 위치에 x축을 놓고 돌리게 되면, z, y의 값이 변형된다. (x축 회전)
// 3D는 이런 회전이 3개 존재.
// 
// 지름으로 원의 둘레를 나눴을 때, 항상 3개로 나눠지고 0.14정도의 수가 남았다. 이게 바로 원주율 -> 그리스때 탄생
// 이 3.14(파이)가 그 당시에는 각도로써 활용됐다.
// 여기서 반지름이 1일 경우를 각도로 사용하기로 했고
// 이 원의 지름은 2가 된다.
// 이러면 2파이가 원의 둘레가 된다.
// 
// 360도는 2파이
// 180도는 파이
// 90도는 파이/2
// (그때는 360도법이 없었음)
//
// 이런 각도가 있는 상태에서 벡터를 잠시 짚고 넘어간다.
// 
// 플레이어 액터의 pos를 창의 중심으로 정했다면, 그것은 0,0에서 부터 뻗어나온 벡터가 그 위치에 존재하도록 하는 것이다.
// 어제 배웠던 가운데에서 회전하는 폴리곤 함수는 0,0의 위치에서 회전시키는 상태에서 위치를 더해서 옮긴 것이다. 크자이공부
// 
// 벡터의 합은 보통 이동에 쓰인다. (Player 움직일때)
// 벡터의 차는 보통 상대를 향한 방향을 알고싶을 때 사용한다 (몬스터의 플레이어 추적)
// 벡터의 곱셈은 벡터의 길이를 늘릴때 사용한다. 이때 방향은 유지되고 길이만 달라진다.
// 
// 플레이어가 마우스 방향으로 총을 발사한다고 했을 때, 결론적으로는 벡터의 차를 구하면 된다.
// 원점 기준에서 생각하면 쉽게 생각 가능.
// 이때 차를 그냥 할당해버리면 그냥 총알이 그 위치에 생성될 뿐이다.
// 이래서 우리는 1단위의 벡터를 만들어서 시간당 날아갈 수 있도록 함. 이걸 노멀라이즈(normalize)
// 
// 우리 엔진에서 math 클래스의 Size()는 벡터의 사이즈를 의미한다.
// 사이즈는 순수한 길이를 구하는 것이다 (절대값) 
// 이 사이즈를 1로 만든다.
// 1이 중요한 이유는
// 1을 시간당으로 곱한다고 생각했을 때,
// 0.1초당 0.1씩 나아가는 벡터로 만들기 편함 등 계산에 용이함. 그래서 단위를 1로 만든다.
// 
// 벡터와 삼각형은 땔래야 땔 수 없는 관계이다.
// 원점에서부터 뻗어나오는 벡터에 대해, x축을 향해 수선의 발을내리면 직각삼각형이 된다.
// 사실, 원점에서 뻗어나오는게 아니더라도 직각삼각형이 된다.
// 여기서 벡터의 값을 나누거나 곱해도, 삼각형의 닮음은 유지된다.
// 
// 또한, y가 0이고 x가 3인 (3,0) 벡터라고 할지라도, 이것은 삼각형의 높이가 0인 삼각형이 존재한다고 생각할 수 있다.
// 이때는 밑변이 빗변이 된다.
// 그리스시대에, 이런 밑변, 빗변, 높이의 관계는 이미 정리되어있다. 피타고라스 정리
// 
// 밑변^2 + 높이^2 = 빗변^2
// 
// Size함수의 x * x + y * y는 결국 빗변 * 빗변인 것이다.
// 빗변 제곱인 것인데, 이 제곱을 풀면 빗변만 남는다.
// sqrtf(빗변^2) = 빗변 이 나온다.
// 제곱근에서도 무리수는 존재하기 때문에, 완벽한 값이 나오지는 않는다.
// 그래도 이걸 구하면 빗변의 길이를 알 수 있기 때문에 개꿀이였다.
// 이 값을 구하고, x, y를 나누면 빗변의 길이가 1이 되면서 x, y가 동일한 비율로 나눠지고 벡터값이 나온다. 이게 노말라이즈~
// 
// // 크자이공부
// 
// 모든 변환은 우리들이 상식적으로 생각하는대로 되려면 크자이 순서로 되야 한다.
// 
// 가운데에서 회전하면서 커지는 경우엔 원점을 기준으로 크기를 키우고, 회전을 시킨 뒤
// 옮겨야한다.
// 
// 크기 : 벡터의 곱셈을 이용한다. 방향은 유지되면서 길이가 길어진다. (모든 vertex에 곱셈 실시)
// 이동 : 벡터의 합을 이용한다. 벡터의 위치가 합만큼 이동된다. (모든 vertex에 덧셈 실시)
// 
// 최초 정점의 위치를 로컬공간이라고 한다.
// 로컬공간에 있는 어떠한 메쉬를 크자이 순서를 통해 원하는 위치에 두는 것이 중요하다.
// 로컬공간은 벡터에서 단위벡터가 중요했던 것 처럼, 1로 선언해둔다.
// 크기를 100 변환시킨다고 했을 경우, int Scale = 100.0f를 선언 >> 생각과 코딩이 동일
// 단위가 1이 아니면, (예를 들어 50이면) 안됨
// 대부분의 메쉬는 1을 기준으로 하는 크기가 중요하다. 100곱하면 100의 크기가 되야한다는 것
// 
// //늘 1이라는 단위가 중요한 이유
// 
// 로컬스페이스에서 크자이공부에 따라 변환되어 날아온 위치 (크기, 자전, 이동이 다 적용된 상태)를 월드 스페이스라고 부른다.
//
// 이동을 안한다는 것은 로컬공간에만 존재하게 되는 것이다. 윈도우 좌표계 기준으로 0,0에만 존재하게 됨
// 우리가 이것을 원하는 공간으로 옮기기 위해서는 이동을 활용해야 한다.
//
// //삼각함수
// 
// 회전을 하려면 기본적으로 삼각함수를 알아야한다.
// 특정 각도일 때의 벡터를 구하는 법을 알면 된다.
// 하나의 축벡터를 기준으로 삼고 거기서 몇도 회전했다고 표현함
// 
// 삼각함수는 그냥 규칙이라고 보면 됨
// 빗변(벡터), 밑변, 높이 직사각형이 있을 떄,
// 빗변의 길이가 아무리 달라져도, 그 비율만큼 밑변과 높이는 변하게 된다.
// 이때 길이가 변하기 전 높이/빗변이 0.6이였다면, 빗변의 길이를 늘려도 그때 직각삼각형의 높이/빗변은 0.6
// 
// 
// (이후 윈api에 정리해둔 txt 파일 내용)
// 
// 
// 
// 
// 
// 
//
//
//
//
//
//