#include "PrecompileHeader.h"
#include <Windows.h>
#include <GameEngineBase\GameEngineFile.h>
#include <GameEngineBase\GameEngineDirectory.h>
#include <GameEngineCore\GameEngineCore.h>
#include <GameEngineContents\CupheadCore.h>

#pragma comment(lib, "GameEngineCore.lib")
#pragma comment(lib, "GameEngineContents.lib")

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
	_In_opt_ HINSTANCE hPrevInstance,
	_In_ LPWSTR    lpCmdLine,
	_In_ int       nCmdShow)
{
	GameEngineCore::Start(hInstance, CupheadCore::GameStart, CupheadCore::GameEnd, { 0, 0 });
}

// ShaderResHelper
// 쉐이더가 자기 안에 들고 있는 상수 버퍼(리소스)
// 
// 우리 엔진에서 엑터와 렌더러가 있다.
// 랜더러는 액터에 여러 개 달릴 수 있음
// 랜더러는 화면에 무언갈 그리고 싶다 하면 만드는 것이다.
// 
// 예전에는 게임엔진 이미지나 랜더러를 통해 그릴 수 있었지만,
// 그린다라는 행위를 함수로 지원하지 않으면 못하는 것.
// 알파블릿, 비트블릿, 트랜스블릿, 피엘지블릿 등
// 랜더링을 하는 것에 관여할 수 없었음
// 함수가 지원하면 하고, 없으면 할 수 없음
// 
// 그런데 이걸 다이렉트 기준으로 생각.
// 함수가 랜더링 하나로 통일됐다.
// 랜더링을 위한 함수가 딱 하나 있음, 그걸 여러 조각으로 쪼개놨음
// 버텍스 쉐이더와 픽셀 쉐이더가 있음
// 그 안에서 투명 처리, 회전 이런걸 다 할 수 있음
// 이를 위해서 버텍스 쉐이더나 픽셀 쉐이더는
// 회전 하려면 몇도? 투명해지려면 얼만큼? 이런걸 모르기 때문에
// 값을 넣어줘야 한다.
// 그러면 그 값은 각자의 랜더러가 가지고 있어야 하는 것이다.(WinAPI도 그랬음)
// 근데 그걸 transform이 가지고 있음
// 
// 예전에는 이미지를 하나만 썼지만, 이미지를 여러개 막 섞어서 쓸 수 있게 됨, 이미지를 하나의 랜더러가 원하는 만큼 가지고 랜더링할 수 있게 됨
// 그래서 오히려 어려워짐
// 단순하게 생각하면, 쉐이더 안에서 이미지 하나 넣고, 반투명 하고싶은 색 하나 넣고 하는 것을 버텍스 쉐이더에 하나씩 넣는다고 하면, WinApi랑 구조가 똑같다.
// 하지만, 지금은 여러 개가 될 수 있기 때문에(제약이 없어짐) 복잡해진것
// 
// 그래서 지금은 하나의 이미지만 랜더링 하는 조건이 아닌, 이미지를 여러 개 랜더링 할 수 있는 베이스를 만들 고 있는 것이다.
// 지금은 이미지를 몇 개 쓰는지 조사하고 있음
// ShaderResourceCheck()
// 
// 어떤 쉐이더에 몇개의 텍스쳐와 몇개의 상수 버퍼를 쓰는지 체크
// 상수 버퍼 n개 쓴다고 하면, 쉐이더 컴파일 후 멀티 맵 자료형의 second로 n개 들어감
// 
// 상수버퍼 세터는 특정 상수 버퍼를 쓰겠다고 지정할 뿐이며 쉐이더 내에 존재한다. 상수버퍼가 존재한다는 것을 기록하기 위한 세터를 쉐이더가 가지고 있는 것.
// 세팅이 되고 값이 멀티맵에 저장된 후
// 
// 쉐이더와 랜더러는 전혀 별개의 것이다.
// 랜더러가 세팅되는 시점(파이프라인과 쉐이더) 어떤 쉐이더를 쓴다고 지정하게 된다.
// 그러면 랜더러가 파이프라인을 가리키게 됨, 그 랜더러 안에 있는 쉐이더를 가리키게 됨
// 랜더러 입장에서 1번 랜더러는 빨간색, 2번 랜더러는 파란색 이런 식일 때,
// 상수 버퍼가 빨간 색이고, 1번, 2번이 이 쉐이더를 가리키면 2번이 빨간색이 될 수 있나? 없음
// 랜더러는 자신이 빨간색이라는 개념을 가질 수 없음. 이건 쉐이더가 가지고 있음
// 
// 이런 것들을 해결하기 위한 구조를 짜는 중
// 쉐이더는 리소스 헬퍼를 가지고 있고 랜더러도 각자 리소스 헬퍼를 가지고 있음
// 이때 랜더러가 쉐이더를 지정하면, 안에 특정 값이 들어있지는 않고 나 상수 버퍼 몇개, 나 텍스쳐 몇개 인 것을 지정하게 됨
// 이게 랜더링파이프라인에서 세팅됨 -> 나 쓸게 하고 연결됨
// 이러면 랜더링파이프라인 내에는 쉐이더들이 들어있고, 쉐이더는 상수버퍼 몇개, 텍스쳐 몇개를 가지고 있는 상황
// 랜더러도 쉐이더리소스헬퍼를 가지고 있기 때문에, 파이프라인 연결 후 헬퍼에 쉐이더의 헬퍼 값(상수 버퍼 몇개, 텍스쳐 몇개)을 복사해서 가져옴
// 그래서 이제 랜더러거 헬퍼에 난 빨간색, 난 배경 / 난 파란색, 난 캐릭터 이런게 가능해짐
// 
// 결국 자신이 세팅값을 가지기 위해 복사하는 과정이였던 것이였던 것이였다.
// 
// 기성엔진은 랜더러마다 랜더링파이프라인을 만들어서 적용해야 한다. 만약 세팅이 다른 랜더러라면 (이게 퍼포먼스 빠름)
// 사실 기성 엔진과 같이 하려면 랜더러 하나 만들 때마다 랜더링파이프라인 하나 만들어야 했음
// 우리는 그거 안할려고 이렇게 함
// 쉐이더가 복사 해주기 전에 조사만 한거임 (상수 버퍼 몇개~ 텍스쳐 몇개~)
// 
// 
// 이제 오늘의 수업
// 
// Pipe->Render 전 ShaderResHelper.Setting() 실시
// 여겄은 상수버퍼 세팅, 텍스쳐 세팅 이런 걸 하는 것
// 쉐이더 값이 이상하다? 여기 보면 됨
// 
// 세터는 세팅된 리소스를 가지고 있음
// 상수버퍼의 세터는 좀 문제가 있다.
// 랜파를 보면 쉐이더마다 상수버퍼가 다 있음
// 픽셀이든 헐이든 도메인이든 버텍스든 어디든 세팅될 수 있음
// GetContext->VSSetConstantBuffers
// GetContext->PSSetConstantBuffers ...
// 인데, 직접 VSSetting, PSSetting 만들어서 그 안에 넣어줌
// 
// 먼저 VSSetting의 VSSetConstantBuffers의 인자를 보자
// 1번 : 몇번 슬롯? 
// 2번 : 몇개냐, 여러개 가능. 지금 당장은 1
// 3번 : Buffer
// 
// 근데 세터는 몇번 슬롯인지 이미 알고있음.
// 그리고 ParentShader도 알고 있음
// ParentShader는 이게 버텍스 쉐이더인지, 픽셀 쉐이더인지를 알 수 있음
// ParentShader.GetType 실시, 스위치문 작성
// 
// 멀티맵으로 한 이유
// b0, b0 똑같이 해도
// 픽셀 쉐이더의 b0과 버텍스 쉐이더의 b0은 겹치지 않는다.
// 애초에 겹치면 VSShaderSetting, PSShaderSetting이 아니라, 그냥 ShaderSetting 이였어애함.
// 문제되는 것은 같은 쉐이더 안에서 b0을 두개 쓸 때임. (?)
// 이름이 겹치는 상수버퍼가 있을 경우(슬롯만 다름) 멀티맵에 넣으면 문제 없음
// 
// 이제 복사된 ResHelper에 값을 지정해주는.
// 이를 위해 SetConstantBufferLink 실시
// 
// lower_bound == 같은 이름 중 가장 앞에 있는 것
// upper_bound == 가장 마지막에 있는 것
// 이것이 멀티맵에서 이터레이터 쓰는 법
// 
// 이름이 링크인 이유~
// 링크함수 이후 색 변경 가능~~
// 그래서 링크~~~
// 
// 버텍스 버퍼는 매쉬가 절대로 안바뀌니까 Usage가 디폴트에 Data를 2번 인자로 박아버림
// 
// 근데 상수 버퍼는 2번 인자가 널 (시시 각각으로 바꿀 예정이기에)
// 그래서 ChageData가 가능해짐 (물론 먼저 세팅이 되있어야함)
// 이게 좋은건 아님. 이거 때문에 머테리얼들은 상수버퍼같은 것을 통일해 놓은 것이다.
// 
// 상수버퍼는 vram 안에 있음
// 일하는 중 그거 쓰려고 하면 큰~ 일이 생김
// 글카는 계속 돌려야하는데, Map이라는 함수는 랜더링 활동을 멈추라고 함
// 이러면 오버헤드가 발생할 수 있다.
// 상당히 그래픽카드를 느리게만들 수 있는 함수이다.
// Map은 너무 많이 호출하거나, 자주 호출하면 안좋다.
// 1번 인자 : 이 버퍼를 고치겠다.
// 2번 인자 : 필요없음
// 3번 인자 : D3D11_MAP_WRITE_DISCARD == 최대한빠르게 처리하라는 뜻
// 4번 인자 : D3D_MAPPED_SUBRESOURCE == 여기에 채워짐
// 
// 다 썼으면 Unmap 실시
// 1번 인자 : 이 버퍼 다씀
// 2번 인자 : 필요없음
// 
// 이후 상수버퍼 세터로 간다.
// ConstantBufferSetter::Setting에서 처음에 Res->ChangeData() 실시하는 인터페이스
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
//