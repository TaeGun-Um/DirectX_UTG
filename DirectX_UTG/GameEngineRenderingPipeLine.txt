
 - 일반적인 랜더링 파이프라인

   모니터는 픽셀의 집합이며 우리는 전혀 보이진 않지만 개념상 월드라는 것(x, y, z로 이뤄진 세상)을 만들어 모니터에 출력하고자 한다.
   어떤 세상에 존재(아직 Mesh라는 것이 없는 것)가 있다는 것을 표현하려고 한다면, 우리 엔진에서는 이를 GameEngineTransform이 도와준다.
   어떤 점이 있다면, 이 점은 점이 바라보는 방향, 점의 위치, 점의 회전 값에 대한 집합(Worldmatrix)을 가지고 있다.
   이 정보만으로는 화면에 출력될 수 없다.
   그렇기 때문에 이 점(vertex)들을 모아(연결) 삼각형(mesh)로 만든다.
   이 삼각형의 각 점들이 우리가 만든 Worldmatrix(행렬)에 영향을 받게 된다.

   삼각형이 화면 가운데에 존재한다고 가정해보자.
   이것이 Worldmatrix에 영향을 받을 경우 크자이공부가 적용된다.
   또한 화면에 출력하기 위해 카메라를 하나 만든다.
   카메라는 화각, near, far 등의 정보를 갖고 뷰 -> 프로젝션 -> 뷰포트 작업을 한 뒤 모니터에 삼각형을 띄운다.
   이때 카메라가 정보를 통해 물체를 화면에 띄우기 전, 물체를 담는 공간을 피라미드(프로스텀)이라고 한다.
   프로스텀 안에 mesh를 가진 존재가 들어오면 뷰포트가 곱해지면서 화면에 위치하게 되는 것이다.
   프로스텀에 포함되지 않는 것들은 화면에 표시되지 않는다.
 
 - Direct의 랜더링 파이프라인

   GameEngineBase의 랜파.jpg를 보면서 확인
   맨 처음 단계 Input Assembler는 점을 준비하라는 뜻이다.
   화살표로 연결된 것, 오른쪽은 구조체, 왼쪽은 리소스이다.

   최초에 화면에 점이 위치한다면, 이건 점이 Worldmatrix를 통해 위치만 결정된 것이다.
   아직 색에 대한 정보는 담고 있지 않다.
   사실 점은 위치 뿐만 아니라 여러 정보를 담을 수 있는데, 두 번째로 중요한 것이 바로 색깔 정보이다.
   화면에 특정 색을 갖는 존재가 표현된다면, 색을 가지고 있다. 이 색을 표현하기 위한 정보를 점이 가지고 있으며 안티얼라이어싱을 통해 색을 결정하는 것이다.
   이 점들을 만들어서 DirectX에게 전달해야 한다.

   지금까지는 점의 위치만 보낸 것이다. 물론 위치 정보는 필수이기 때문에 보내야 한다.
   
   이를 위해 GameEngineVertex를 추가하여 내부에 float4 Vertex, float4 Color를 추가한다.

 - 인스턴스 버퍼
   Input Assembler에 화살표 왼쪽으로 연결된 부분에서 인스턴스 버퍼란, DirectX에 자신이 넣은 점들의 갯수와, 그걸 어떤 순서로 그릴지에 대한 정보를 넘겨줘야 한다.
   사실 Direct에서는 mesh라는 개념이 없다. 사람들이 그저 vertext와 instance가 합쳐진 상태를 mesh라고 부를 뿐이다. Direct에서는 둘이 합쳐진 상태를 버텍스 버퍼라고 부른다.
   아무튼 mesh(버텍스버퍼)는 버텍스와 인스턴스 버퍼로 이뤄져 있고, 점만 놓여져 있는 것이라면 이 점을 그리는 것이 인스턴스 버퍼이다.
 
 지금까지는 점의 위치만 보낸 것임(위치는 물론 필수)
 점에는 위치 뿐만 아니라 여러 정보를 담을 수 있다.
 
 리소스에 GameEngineVertex 추가
 인스턴스 버퍼 == 다이렉트X에 자신이 넣은 점들의 갯수와, 그걸 어떤 순서로 그릴 지 정보를 넘겨줘야함
 매쉬는 버텍스와 인스턴스 버퍼로 이뤄짐
 초반에는 사실 버텍스랑 인스턴스 두개 합쳐진 상태를 매쉬라고 부르지도 않음
 사람들끼리 매쉬라고 부르기로 약속한 단어임
 다렉에서는 버텍스버퍼라고 부른다. 점만 놓고 보면
 이 점을 그리는 건 인스턴스 버퍼라고 한다.

 // 아직 Input Assembler1 단계가 끝나지 않았음
// 랜더링파이프라인을 하나로 묶는 클래스를 만들 예정, 아직 멀었음
// 
// 여기 있는 Input Assembler1
// 랜더링은 GERenderer가 할 예정
// 
// 머터리얼은 결국 랜더링파이프라인을 표현하기 위한 것이다.
// 순수한 다렉의 랜더링파이프라인을 표현하진 않음
// 랜더링파이프라인은 3D 라이브러리 따라 방식이 조금씩 다르다.
// 
// 우리는 다렉을 만드는게 아니고 다렉 라이브러리를 빌려쓰는 사람
// 그래픽스적인 라이브러리는 종류가 굉장히 많다.
// 
// 유니티 입장에서 생각
// 윈도우에서 빌드 안드로이드 빌드 리눅스 빌드 가능
// 리눅스에서 다렉 사용 불가
// 그러니 유니티 엔진은 외부에 보일 때 다이렉트X 랜파라고 표현하면 의미가 없다.
// 각 랜파들의 이론을 공부하는게 어마어마하게 어려움
// 유니티 엔진 만지작하는 사람들 : opengl 전문가, directx 전문가 등이 있을 것
// 것으로 봤을 때, 안드로이드면 opengl용 클래스, 윈도우면 directx용 클래스 이런 식으로 호출하게 만들지 않음
// 그런 프로그래머들이 대부분 정점과 뭐가 합쳐진 것을 mesh라고 부르기로 정한것일 뿐
// 우리가 지금 배우고 있는 다렉 랜파 단계는 mesh라는 개념이 존재하지 않는다.
// 
// Index 버퍼가 점을 그리는 순서를 정해주는 것
// 
// 다렉에서는 mesh를 표현하기 위해서 vertex와 index를 합치면 mesh가 되는 것(mesh가 되는 것은 아니고 그에 준하는 개념이 되는 것)
// 
// 아마 언리얼이나 유니티 해봤다면 머터리얼을 봤을 텐데, 이것도 다렉 랜파에는 나오지 않는다.
// 그냥 과정을 합쳐서 좀 더 편하게 표현하기 위한 개념을 만든 것일 뿐
// 퉁쳐서 눈에 보이는거 ; 매쉬, 색깔 바꾸는거 : 머터리얼 로 표현하는 것~~~
// 
// 인풋어셈블러1 화면에 나오는 색이 입혀지지 않은 캐릭터를 생각해보자. 이게 매쉬다.
// 매쉬를 이루는 점의 정보를 준비한다.
// Context->IASetVertexBuffer()
// id311buffer
// 
// VertexShader(Vertex _한개);
// Context->VSSetShader()
// 정점 4개로 이뤄진 rect를 그리면? 버텍스 쉐이더는 네 번 동작한다.
// 버텍스 쉐이더 : CoreResoucresInit을 보면 버텍스 네 개는 로컬에 존재한다.
// 이 로컬의 점들을 행렬을 통해 변환한다.
// 여기서 뷰~프로젝션 행렬 실시
// 버텍스 쉐이더에서는 프로젝션 이후 w 나누기를 안한다.
// w 나누기를 하지 않으면 -1 ~ 1 공간에 들어가지 않는다.
// 
// 인풋어셈블러2 : 점의 정보를 토대로 어떤 순서로 그릴지 정한다.
// Context->IASetIndexBuffer()
// 
// 여기서 부턴 다음 절취선까진
// ------------------------------------------------------------------------
// 
// Hullshader과 테셀레이션 단계는 의미 없다고 봐서 안할 예정
// 버텍스 쪼개기
// 테셀레이션은 지형이나 매쉬를 표현할 때 버텍스를
// 일반적으로 매쉬 보면 알겠지만, 만들어진 rect가 있으면, 그게 바뀜?
// 테셀레이션은 그걸 뒤틀 수 있는 것임
// 멀리서 볼때는 매쉬의 버텍스 갯수가 적게 보이게 하고, 가까이서 보면 상세하게 표현하는 단계
// 
// 캐릭터의 얼굴 매쉬가 100만 메쉬라고 할 때, 멀리서 본다고 가정해보자.
// 멀리서 볼땐 100만 매쉬가 아닌 만개로 그리도록 하는 것, 이걸 lod라고 한다. (Level of detail)
// 매쉬(버텍스 버퍼 + 인덱스 버퍼)를 단계에 따라 n개 만들어라~
// 매쉬 단계를 5개로 나눈다 했을 때
// 천개
// 오천개
// 만개
// 십만개
// 백만개
// lod가 달라지는 것
// 
// 도메인 쉐이더 << 이것도 안함, 입자 처리
// 지오메트리 쉐이더 << 도메인과 이걸 나눠서 볼 수 있음 버텍스 생성
// 이 단계는 없던 버텍스를 생성하는 단계, 파티클을 만들 때 사용한다.
// 파티클은 어마어마하게 많은 양의 동일한 버텍스를 뿌릴 때
// 
// 지오메트리와 인스턴싱이 있는데, 인스턴싱이 쬐끔 더 빠름
// 
// 도메인 쉐이더에서 어떤 점이 들어오면 특정 정보를 부여하고
// 지오메트리는 더 만들고 어떻게 그릴지 정함
// CPU에서 했던 CoreResourcesInit()을 그래픽카드한테 시킬 수 있다는 것이다.
// --------------------------------------------------------------------------------
// 
// Context->RSSetState()
// 래스터라이저 << 뮈췬듯이 중요함
// w 나누기를 해준다. 뷰포트도 곱해준다. 화면 컬링도 해줌
// 화면 컬링이란 : 화면에 잘려있는 액터를 싹둑 자르는 것
// 픽셀 건지기도 한다(선생님 표현)
// 물체가 존재해야 하는 픽셀을 체크
// 
// Context->PsSetShader()
// 컬러 PixelShader(Pixel _한개); >> 정보가 들어왔을 때, 리턴 빨간색~ 하면 해당 픽셀이 빨간색이 된다.
// 픽셀쉐이더
// 이제 체크된 픽셀 하나하나가 있을 것이다. 점의 정보를 가져와서 픽셀에 어떻게 표현할 지 정함.
// 
// 매쉬는 결국 모니터에 표현하고 싶은 범위를 정하는 것
// 
// 픽셀 셰이더랑 버텍스 셰이더 없이 화면에 뭔가 그릴 수 없음
// 절취선 부분은 초반에는 큰 의미가 없음
// 
// 아웃풋머저 Context->OMSetREnderTarget() : 어떤 랜더 타겟을 밑바닥에 깔아놓을것이냐
// 픽셀 세이더까지 해서 색이 정해졌다고 하자.
// 이미지 로드 할때마다 랜더 타겟 엄청 생겼음
// 픽셀 쉐이더로 색이 나왔다 하면
// 이게 어느 랜더 타겟에 칠해질지 정해져야함.
// 백버퍼? 내가 로드한 이미지?
// 그 중에서 하나를 간택하는걸 아웃풋머저가 한다.
// 
// 특정 랜더 타겟을 마지막에 도화지에 찍음 (모니터에 찍히는게 아니라 랜더타겟에 찍히는 것)
// 
// 그러면 텍스쳐로드로 백버퍼에 복사~
// 
// IAVertexBuffer
// 1번 인자 : (버퍼의 배열이니까) 근데 의미없음, 하나 만들었으니깐 
// 2번 인자 : 버텍스를 얼마나 만듦? 여러개를 만들어 셋팅할 일이 있나? 풀어줄지 모르겠다.
// 3번 인자 : ID311Buffer (버퍼의 배열)
// 4번 인자 : 버텍스 하나 크기 알려줘
// 5번 인자 : 오프셋 버텍스 몇번째부터?
// 
// 버텍스 세이더 하면 다시 한 번 Iavertexbuffer로 넘어올 거임 << 이거 나중에 쓰다가 알려줄 예정
// 
// 버퍼가 ID3D11Buffer를 공유하는 것 처럼
// 쉐이더는 ID3DBlob을 공유한다.
// 쉐이더 코드를 이진 데이터로 변형했을 때 그걸 그래픽 카드가 내부에 숨기고 이걸 제공함
// 
// 쉐이더는 Hlsl
// 다렉 초기 버전은 할 수 있는게 없었음
// 매쉬 넣어주고 머터리얼 정하면 화면에 나오는 정도
// 욕망이 생김
// 텍스쳐 여러개 넣고 싶다
// 텍스쳐 어떤 곳은 다른 색으로 출력하고 싶다.
// 엔진은 유저가 뭘 원하는지 모름 알도리가 없읍니다.
// 그래서 아예 니가 쳐라
// 니가 쳐서 규칙만 주면 그래픽카드에서 처리해줄게 가 됐음
// 픽셀셰이더, 버텍스 셰이더를 짜서 줘라~
// 
// 그래서 전혀 다른 곳에 셰이더 코드를 짜놓고 경로를 알려주면 버텍스셰이더 로드를 해서
// 어딘가의 텍스트파일에 적용하는 방식
// 엔진에 셰이더 올릴라 하는데 자기 파일 만들어서 거따 올려라.셰
// 경로 탐색하고 로드하는 함수 알려줄 예정.
// 
// Fx나 hlsl이 있는데, 확장자에 큰 의미 없음
// 의미부여하지마라
// 
// 확장관리 우측 상단에 HLSL 검색하면
// HLSL Tools for Visual Studio 선택
// 인텔리센스가 hlsl에서도 동작하도록 해준다.
// 
// 옮기고 다 지워~
// 그리고 함수를 만든다.
// 셰이더 규칙
// 어떤 정보가 들어올지 구조체 만듦
// float Pos, float Color
// 밖에서 void 포인터랑 전체 크기만 가진 덩어리가 날라오는 것
// 셰이더는 어디가 Pos고, 어디가 Color이고, 어디가 뭔지 알아야함
// 셰이더는 구조체로 그게 뭔지 알도록 해줘야함.
// 구조체 이름 맘대로 해도 댐
// 셰이더 문법 첫 번째 시멘틱
// : 뒤에 있는것 == 어떤 역할을 가졌는지
// 이걸 안붙여주면 셰이더쪽에선 바이트덩어리가 날라왔는데, 크기는 알아.
// IaSetBuffer할때 날아옴 (GameEngineVertexBuffer::Setting)
// 나에게 몇 개의 점이 날아왔는지 알 수 있음
// 근데 내부는 뭔지 몰라~ 그래서 구조체로 알려줘야함
// 
// 버텍스 하나 들어왔다 > 어떻게 해줘~  이게 for문 돈다.
// 
// 버텍스 셰이더에서 프로젝션 해야 
// 레스터라이저에서 w 나누기를 할 수 있음 ( 뷰포트까지 곱해줌)
// w 나누기 할 때 사용할 z값이 프로젝션 이후 담기기 때문
// 
// Color도 여러 개 넣어줄 수 있으니 Color[n]이 뜸
// SV_Position << 레스터라이져한테 이 포지션이 w 나눈 후 뷰포트 곱하고 픽셀 건져낼 때 쓸 포지션 정보를 내가 보낸 것이라고 알려주는것
// 
// 속성 " 진입점 이름 main 지워버리기
// 셰이더는 빌드에 포함 안댐